<!--
`hax-body-behaviors`
A behavior for mixing-in structure for elements to communicate effectively
with the hax-body element which manages elements.

@microcopy - the mental model for this element
 - context - hax-body has context menus to provide options related to the active element
 - haxProperties - a mapping of properties to what inputMethod types to place on the menu

-->
<script>
  /**
   * In order to use this, the user must supply a haxProperties object
   * which returns what settings are allowed as well as their format.
   * For example, the default of:
   *
   *  {
   *    'canScale': true,
   *    'canPosition': true,
   *    'settings': null,
   *  }
   *
   *  Tells hax-body's context menu for custom-elements that this element
   *  can use the scaling widget and the positioning widget as globals.
   *
   * Other settings can be expressed through beyond these simple layout modifiers.
   * The following example expresses a citation property which creates a textfield
   * on the context bar with a text-format icon for inputMethod. It also illustrates how
   * this could be applied to slots for more flexible content inputMethod as well as a
   * potential boolean value in an "Advanced" area.
   * 'settings': [
   *   {
   *     'property': 'citation',
   *     'title': 'Citation',
   *     'description': 'Proper MLA or other standard citation format for the image.',
   *     'inputMethod': 'textfield',
   *     'type': 'bar',
   *     'icon': 'text-format',
   *     'required': true
   *   },
   *   {
   *     'slot': 'area1',
   *     'title': 'Section 1',
   *     'description': 'Content that goes in the fist area in the layout.',
   *     'inputMethod': 'textarea',
   *     'type': 'settings',
   *     'icon': 'layout'
   *   },
   *   {
   *     'property': 'responsive',
   *     'title': 'Responsive',
   *     'description': 'The video automatically fills the available area.',
   *     'inputMethod': 'boolean',
   *     'type': 'advanced',
   *     'icon': 'video'
   *   }
   * ]
   */
  // ensure HAXPropertiesBehaviors exists
  window.HAXBehaviors = window.HAXBehaviors || {};
  // ensure we have consistent reporting of haxBodyProperties
  window.HAXBehaviors.PropertiesBehaviors = {
    properties: {
      /**
       * haxProperties
       */
      haxProperties: {
        type: Object,
        value: {
          'canScale': true,
          'canPosition': true,
          'settings': [],
        },
        readOnly: true,
      },
    },
    /**
     * Setter to bridge private haxProperties setter.
     * This is to then be implemented by the ready state of whatever is supplying the
     * properties in order to be able to bubble up the properties for a tag.
     */
    setHaxProperties: function (props) {
      // these are a core piece of hax capabilities
      // set them in the event this got called without anything
      // so we at least won't bomb
      if (typeof props.api === typeof undefined) {
        props.api = '1';
      }
      // sets us up for future API versioning of property validation
      // and clean up.
      if (props.api == '1') {
        if (typeof props.canPosition === typeof undefined) {
          props.canPosition = true;
        }
        if (typeof props.canScale === typeof undefined) {
          props.canScale = true;
        }
        // while not required, this is where all the raw power of this
        // approach really lies since this wires properties/slots to HAX's
        // ability to manipulate things via contextual menus
        if (typeof props.settings !== typeof undefined) {
          // validate properties to ensure each has defaults in place to match the model
          for (i = 0; i < props.settings.length; i++) {
            // we don't have a property or slot so it's not valid.
            if (typeof props.settings[i].property === typeof undefined && typeof props.settings[i].slot === typeof undefined) {
              props.splice(i, 1);
              continue;
            }
            // ensure there's a title
            if (typeof props.settings[i].title === typeof undefined) {
              props.settings[i].title = props.settings[i].property;
            }
            // ensure there's at least an empty description
            if (typeof props.settings[i].description === typeof undefined) {
              props.settings[i].description = '';
            }
            // ensure there's at least an input method
            if (typeof props.settings[i].inputMethod === typeof undefined) {
              props.settings[i].inputMethod = 'textfield';
            }
            // ensure there's at least a type
            if (typeof props.settings[i].type === typeof undefined) {
              props.settings[i].type = 'settings';
            }
            // ensure there's at least an icon
            if (typeof props.settings[i].icon === typeof undefined) {
              props.settings[i].icon = 'android';
            }
            // ensure there's at least an empty options area
            if (typeof props.settings[i].options === typeof undefined) {
              props.settings[i].options = {};
            }
            // ensure there's required set
            if (typeof props.settings[i].required === typeof undefined) {
              props.settings[i].required = false;
            }
            // ensure there's validation or make it anything if none set
            if (typeof props.settings[i].validation === typeof undefined) {
              props.settings[i].validation = '.*';
            }
            // ensure there's validation or make it anything if none set
            if (typeof props.settings[i].validationType === typeof undefined) {
              props.settings[i].validationType = '';
            }
          }
        }
        this._setHaxProperties(props);
      }
      else {
        // especially useful during development if we implement our own API
        // incorrectly. Don't hard brick cause it'll still more or less work
        // but would probably default to an iframe which is less then ideal
        // but at least wouldn't brick the AX.
        console.log('This is\'t a valid usage of hax-body-behaviors API. See hax-body-behaviors for more details on how to implement the API. Most likely your hax item just was placed in an iframe as a fallback as opposed to a custom element.');
      }
    },
    /**
     * Match convention for set.
     */
    getHaxProperties: function() {
      return this.haxProperties;
    },
    /**
     * Get a prototype settings property.
     */
    prototypeHaxProperties: function() {
      // example properties valid for HAX context menu.
      let props = {
        'api': '1',
        'canScale': true,
        'canPosition': true,
        'settings': [
          {
            'property': 'title',
            'title': 'Title',
            'description': '',
            'inputMethod': 'textfield',
            'type': 'settings',
            'options': {},
            'icon': 'android',
            'required': false,
            'validation': '.*',
            'validationType': 'text',
          }
        ]
      };
      return props;
    },
  };
</script>